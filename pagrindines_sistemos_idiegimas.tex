\chapter{Pagrindinės sistemos įdiegimas}
  \section{Naujausios įdiegimo laikmenos gavimas}

  Arch Linux oficialią įdiegimo laikmeną galite gauti iš
  \textsl{http://archlinux.org/download}. Vadovo rašymo metu,
  naujausia versija yra 2010.05.
  \begin{itemize}
    \item Tiek \textsl{Core} tiek \textsl{Netinstall} atvaizdai
      suteikia tik pagrindinę sistemą. Verta pastebėti, jog
      pagrindinėje Arch Linux sistemoje nėra jokios grafinės
      aplinkos. Pagrindinė sistema susideda iš GNU įrankių grandinės ( kompiliatoriaus,
      asmeblerio, linkerio, kt. ), Linux branduolio ir kelių papildomų
      bibliotekų ir modulių.
    \item Įdiegimas yra palengvintas tiek \textsl{Core}, tiek
      \textsl{Netinstall} atvaizduose.
    \item \textsl{Netinstall} atvaizdas yra mažesnis, bet jame
      visiškai nėra pagrindinės sistemos paketų. Visa sistema yra
      parsiunčiama iš interneto.
  \end{itemize}

  \section{Sistemos įdiegimas iš egzistuojančios GNU/Linux
    distribucijos}

  Arch Linux yra pakankamai lankstus, kad galėtų būti įdiegtas iš
  kitos, egzistuojančios distribucijos į laisvą patriciją arba iš Live
  CD.
  Įdiegimą iš egzistuojančios GNU/Linux distribucijos apžvelgsime
  vadovo pabaigoje.

  % TODO:
  % http://wiki.archlinux.org/index.php/Install_from_Existing_Linux

  \section{Įdiegimas iš CD laikmenos}
  
  Iškepkite atsiųstą .iso atvaizdą į CD arba DVD su mėgstama CD/DVD
  rašymo programa ir tęskite savo kelią į kitą skyrių \textsl{Arch
    Linux įdiegimo krovimas}

  \section{Diegimas iš Flash atminties kortelės arba USB atmintinės}

  Sekantis metodas veiks bet kokiam Flash atminties tipui, kurį BIOS
  leis krauti paleidimo metu, būtų tai kortelių skaitytuvas arba USB
  portas.

  \paragraph{UNIX Metodas}
  
  Įdėkite tuščią arba nereikalingą flash laikmeną, nustatykite iki jos
  kelią ir įrašykite .iso atvaizdą, pasitelkus \textsl{/bin/dd}
  programą:

  \begin{verbatim}
dd if=archlinux-2010.05-{core|netinstall}-{i686|x86_64|dual}.iso\
  of=/dev/sdx
  \end{verbatim}

  kur $if=$ yra kelias iki atvaizdo failo ir $of=$ yra kelias iki Jūsų
  flash laikmenos. Įsitikinkite, kad naudojate \textsl{/dev/sdx}, o ne
  \textsl{/dev/sdx1}. Jums reikės flash atminties tiek, kad joje
  tilptų 381MB duomenų.

  \paragraph{Patikrinkite md5sum}

  Pasižymėkite koks buvo įrašų (blokų) skaičius, kai buvo rašoma į
  laikmeną. Tuomet galima patikrinti:

  \begin{verbatim}
dd if=/dev/sdx count=irasu_skaicius status=noxfer | md5sum
  \end{verbatim}

  Patikrinimo kodas turi sutapti su parsiųsto atvaizdo md5sum.

  %TODO: Microsoft Windows Method

  \section{Arch Linux įdiegimo krovimas}
  
  Įdėkite CD ar Flash laikmeną, perkraukit kompiuterį ir paleiskite
  sistema iš CD ar Flash laikmenos. Jums gali prireikti pakeisti
  krovimosi eiliškumą BIOS nustatymuose arba paspausti kažkokį
  mygtuką. Dažniausiai toks mygtukas būna DEL, F1, F2, F11 arba
  F12. Pabandykite paspausti vieną iš jų, kuomet BIOS yra POST ( Power
  On Self-Test ) režime.

  Pastaba: Atminties reikalavimai baziniam įdiegimui yra tokie:
  \begin{itemize}
    \item \textsl{Core} : 128 MB RAM x86$\_$64/i686 ( pažymėti visi
      paketai, su swap particija )
    \item \textsl{Netinstall} : 128 MB RAM x86$\_$64/i686 ( pažymėti
      visi paketai, su swap particija )
  \end{itemize}

  Šiame žingsnyje turėtų pasirodyti pagrindinis menu. Pasirinkite
  Jums reikalingą opciją klaviatūros navigaciniais mygtukais ir padarę
  pasirinkimą paspauskite 'Enter' mygtuką.

  Dažniausiai, pirmą kartą kraunant Arch Linux \textsl{Boot Archlive}
  yra tas pasirinkimas, kurio Jums reikia. Tačiau, jeigu turite bėdų
  su libata/PATA arba neturite SATA (Serial ATA), pasirinkite
  \textsl{Boot Archlive [legacy IDE]}.

  Norint pakeisti GRUB pasirinkimus, paspauskite raidę
  \textbf{e}. Dauguma vartotojų norės pakeisti framebuffer
  rezoliuciją, patogesniam darbui. Pridėkite:
  \begin{verbatim}
vga=773
  \end{verbatim}
  kernelio eilutėje. Tuomet paspauskite \textbf{Enter} mygtuką, kad
  įgalinti 1024x768 framebuffer rezoliuciją. Kuomet viskas bus
  padaryta, paspauskite \textbf{b} mygtuką, kad pradėti sistemos
  krovimą.

  Dabar sistema turi pradėti krautis. Kuomet sistema pilnai pasikraus,
  turėtų pasirodyti prisijungimo galimybė. Prisijunkite kaip
  \textsl{root} vartotojas, kadangi Archlive diske iš \textsl{root}
  vartotojo nereikalaujama slaptažodžio.

  \paragraph{Klaviatūros išdėstymo keitimas}

  Jeigu turite ne US klaviatūros išdėstymą, tuomet Jums reikia ją
  pasikeisti. Tai galima atlikti su \textsl{km} komanda:
  \begin{verbatim}
km
  \end{verbatim}
  arba panaudoti \textsl{loadkeys} komandą:
  \begin{verbatim}
loadkeys layout
  \end{verbatim}
  ( pakeiskite \textsl{layout} su Jūsų pasirinktu klaviatūros
  išdėstymu ).

  Dauguma lietuviškų klaviatūrų yra US standarto su papildomais
  lietuviškais simboliais, kurie pasirodo vietoj skaičių eilės,
  esančios virš \textsl{q,w,e,r,t,y,u,i,o,p} klavišų eilės. Tai
  reiškia, kad daugumoje atveju, Jums visiškai nereikia keisti
  klaviatūros išdėstymo.

  \paragraph{Dokumentacija}

  Oficialus įdiegimo vadovas yra pasiekiamas iškarto diske. Norint jį
  pasiekti, persijunkite į kitą konsolę ( ALT+F2 ) ir tuomet surinkite
  tokią komandą:
  \begin{verbatim}
less /usr/share/aif/docs/official_installlation_guide_en
  \end{verbatim}

  \textsl{Less} komanda leis Jums peržvelgti visą vadovą
  puslapiais. Norint persijungti atgal į įdiegimą, tiesiog paspauskite
  Alt+F1 ir grįšite į pirmą konsolę, kurioje yra vykdomas įdiegimas.

  Prireikus vėl paskaityti dokumentaciją, tiesiog persijunkite į antrą
  terminalą su Alt+F2, norint grįžti prie įdiegimo - Alt+F1.

  Pastaba: Įsidėmėkite, kad oficialus įdiegimo vadovas apžvelgia tik
  pagrindinės sistemos įdiegimą ir konfigūravimą. Kai tik su
  pagrindine sistema yra susitvarkyta, rekomenduojama grįžti prie
  detalesnio vadovo, kuriame yra aprašyti visi reikalingi žingsniai po
  įdiegimo.

  \section{Įdiegimo paleidimas}

  Kuomet esate prisijungė kaip \textsl{root} vartotojas, pirmame
  terminale galite paleisti įdiegimo skriptą:
  \begin{verbatim}
/arch/setup
  \end{verbatim}

  \subsection{Įdiegimo šaltinio pasirinkimas}

  Po pasisveikinimo, Jūsų paprašys pasirinkti įdiegimo
  šaltinį. Priklausomai nuo ankstesnės laikmenos pasirinkimo,
  atitinkamai pasirinkite ir įdiegimo šaltinį.
  \begin{itemize}
    \item Jeigu pasirinkote \textsl{Core} įdiegimo atvaizdą, tęskite
      toliau prie skyriaus \textsl{Laikrodžio nustatymas}
    \item Jeigu pasirinkote \textsl{Netinstall}, Jums reiks rankiniu
      būdu užkrauti tinklo plokštės tvarkykles ( žinoma, jeigu sistema
      automatiškai neaptiks Jūsų turimos įrangos ). Udev yra labai
      naudingas įrankis, norint sužinoti Jūsų turimą įrangą. Tai
      galima patikrinti, pasitelkus \textsl{ifconfig -a} komandą.
  \end{itemize}

  \paragraph{Tinklo konfigūravimas (Netinstall)}

  Šitam žingsnyje, sistema turi parodyti jos rastus tinklo
  sąsajas. Jeigu sąsaja ir HWaddr ( HardWare address ) yra sąraše,
  tuomet Jūsų tinklo plokštė buvo sėkmingai aptikta ir jos tvarkyklės
  sėkmingai įkrautos į branduolį. Jeigu Jūsų tinklo plokštė atpažinta
  nebuvo, tuomet Jums reikia rankiniu būdu kelti tvarkykles į
  branduolį kitoje konsolėje.

  Atsiradus panašiam langui, bus paprašyta pasirinkti \textsl{sąsają},
  \textsl{zondą} arba \textsl{Atšaukti}. Pasirinkite reikiamą
  \textsl{sąsają} ir tęskite.

  Paskui įdiegimo programa paklaus Jūsų ar Jūs norite naudoti
  \textsl{DHCP}. Pasirinkus \textsl{Yes}, įdiegimo programa paleis
  \textbf{dhcpcd}, kuri aptiks tinklo sąsaja ir iš sąsajos reikalaus
  IP adreso. Jeigu pasirinksite \textsl{No}, tuomet įdiegimo programa
  paprašys Jūsų įvesti statišką IP, tinklo kaukę, transliatorių,
  tinklo sąsajos DNS IP, HTTP ir FTP proxy. Paskutiniame žingsnyje
  sistema parodys gautus nustatymus. Šitame žingsnyje galite patikrinti
  ar visi nustatymai yra teisingi.

  \paragraph{Greitasis (A)DSL paleidimas}

  ( Jeigu turite modemą arba routerį tilto režime, jungiantis per ISP
  jungtį )

  Persijunkite į kitą konsolę ( ALT+F2 ), prisijunkite kaip
  \textsl{root} vartotojas ir rašykite:

  \begin{verbatim}
pppoe-setup
  \end{verbatim}

  Jeigu viskas sukonfigūruota teisingai, pabaigoje galite prisijungti
  prie savo ISP su:

  \begin{verbatim}
pppoe-start
  \end{verbatim}

  Grįžkite į pirmą konsolę ( ALT+F1 ) ir tęskite įdiegimą
  \textsl{Laikrodžio nustatymas} skyriuje.

  \paragraph{Greitasis bevielio tinklo paleidimas}

  ( Jeigu turite bevielio ryšio galimybę įdiegimo metu )

  Šiuo metu bevielio ryšio tvarkyklės yra pasiekiamos ir iš įdiegimo
  aplinkos atvaizdo. Geras savo bevielio įrangos žinojimas šiuo atveju
  Jums labai padės. Įsidėmėkite, jog sekantys nustatymai galios tik
  dabartinėje aplinkoje. Kuomet baigsite įdiegimą, visus nustatymus
  reiks pakartoti įdiegtoje sistemoje, norint ir toliau naudotis
  bevieliu ryšiu.

  Taip pat verta pastebėti, jog šie žingsniai nėra privalomi, jeigu
  įdiegimas yra įmanomas ir be bevielio tinklo. Bevielio tinklo
  konfigūravimas gali būti atliktas ir po įdiegimo pabaigos, jau
  įdiegtoje sistemoje.

  Pagrindiniai žingsniai būtų tokie:

  \begin{itemize}
    \item Persijunkite į laisvą konsolę ( pavyzdžiui 3, ALT+F3 );
    \item Prisijunkite kaip \textsl{root} vartotojas;
    \item ( Nebūtina ) Identifikuokite savo bevielio ryšio sąsają:
      \begin{verbatim}
lspci | grep -i net
      \end{verbatim}
    \item Įsitikinkite, kad \textsl{udev} atpažino bevielio ryšio
      kortą ir pakrovė į branduolį reikalingus modulius. Tai galima
      patikrinti su \textsl{/usr/bin/iwconfig} komanda:
\begin{verbatim}
iwconfig
\end{verbatim}
      Rezultatas turėtų būti kažkas panašaus:
\begin{verbatim}
lo no wireless extensions.
eth0 no wireless extensions.
wlan0    unassociated  ESSID:""
         Mode:Managed  Channel=0  Access Point: Not-Associated   
         Bit Rate:0 kb/s   Tx-Power=20 dBm   Sensitivity=8/0  
         Retry limit:7   RTS thr:off   Fragment thr:off
         Power Management:off
         Link Quality:0  Signal level:0  Noise level:0
         Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
         Tx excessive retries:0  Invalid misc:0   Missed beacon:0
\end{verbatim}
      Šiame pavyzdyje, \textsl{wlan0} ir bus bevielio ryšio sąsają,
      per kurią galima jungtis prie bevielio tinklo.
    \item Sekantis žingsnis būtų įgalinti sąsają su
      \textsl{/sbin/ifconfig <sąsaja> up} komanda.
      Pavyzdys, turint \textsl{wlan0} sąsają:
\begin{verbatim}
ifconfig wlan0 up
\end{verbatim}
      Įsidėmėkite, jog Jūsų sąsajos pavadinimas gali būti kitoks, negu
      \textsl{wlan0}. Priklausomai nuo modulio, kurį užkrovė
      \textsl{udev}, Jūsų sąsajos pavadinimas gali būti
      \textsl{wlan0}, \textsl{eth1}, kt.

    \item Jeigu nežinote tiksliai savo bevielio tinklo \textsl{essid}
      arba norite pasijungti prie Jums nežinomo bevielio tinklo,
      naudokite \textsl{/sbin/iwlist <sąsaja> scan} komanda. 
\begin{verbatim}
iwlist wlan0 scan
\end{verbatim}
      Šį komanda peržvelgs šiuo metu pasiekiamus bevielio ryšio
      tinklus.
    \item Sekantis žingsnis būtų nurodyti Jūsų bevielio tinklo sąsajai
      tinklo \textsl{essid}. Priklausomai nuo bevielio tinklo kodavimo
      algoritmo (WEP, WPA arba išvis jokio), nurodymo procedūra gali
      skirtis. Pavyzdžiui galima padaryti prielaidą, jog Jūs norite
      prisijungti prie \textsl{atviras-tinklas};
    \item Jeigu tinklas nekoduojamas:
\begin{verbatim}
iwconfig wlan0 essid "atviras-tinklas"
\end{verbatim}
    \item Jeigu tinkle naudojamas WEP kodavimas su aštuntainiu
      apsaugos kodu:
\begin{verbatim}
iwconfig wlan0 essid "atviras-tinklas" key 25dfb2575a
\end{verbatim}
    \item Jeigu tinkle naudojamas WEP kodavimas su ASCII slaptažodžiu:
\begin{verbatim}
iwconfig wlan0 essid "atviras-tinklas" key s:slaptaszodis
\end{verbatim}
    \item Tinkle naudojant WPA, prisijungimo procedūra šiek tiek
      tampa sudėtingesne. Vėliau tokius pat rezultatus galima pasiekti
      pasitelkiant \textsl{netcfg} įrankį. Tolesnės komandos sugeneruos Jums
      konfigūracinius failus ir pabandys prisijungti prie tinklo:
\begin{verbatim}
wpa_passphrase atviras-tinklas "slaptazodis" >>/etc/wpa_supplicant.conf
wpa_supplicant -B -Dwext -i wlan0 -c /etc/wpa_supplicant.conf
\end{verbatim}
      Verta pastebėti, jog antra komandai reikia žinoti kokias
      tvarkykles naudoja bevielio tinklo sąsaja. Šiuo atvėju tai
      \textsl{wext}. Prieš rašant šią komanda verta patikrinti kokias
      tvarkykles į branduolį įkrovė \textsl{udev}.
    \item Patikrinti ar visas procesas įvyko sėkmingai galima su:
\begin{verbatim}
iwconfig wlan0
\end{verbatim}
    \item Toliau sekantis žingsnis būtų paprašyti bevielio tinklo
      prisijungti su \textsl{/sbin/dhcpcd <sąsaja>}. Pavyzdžiui:
\begin{verbatim}
dhcpcd wlan0
\end{verbatim}
      Norint pamatyti kreipimosi detales, galima pridėti \textsl{-d}
      opciją ir \textsl{dhcpcd} parodys visus savo žingsnius:
\begin{verbatim}
dhcpcd -d wlan0
\end{verbatim}
    \item Paskutinis žingsnis būtų patikrinti ar dhcpcd sėkmingai
      sujungė su bevielio tinklo maršrutizatoriumi ir Jūs turit
      internetą:
\begin{verbatim}
ping -c 3 www.google.lt
\end{verbatim}
      
  \end{itemize}

Dabar Jūs jau turėtumėt būti prisijungę prie interneto ir dabar galite
sėkmingai tęsti Arch Linux įdiegimą į Jūsų kompiuterį, naudojantis
\textsl{Netinstall } atvaizdą.

\paragraph{Ar mano bevielio tinklo korta reikalauja Firmware?}

Labai mažas bevielio tinklo kortų, kartu su tvarkyklėmis, reikalauja
ir firmware. Tai galima patikrinti su \textsl{/usr/bin/dmesg}
komanda. 
\begin{verbatim}
dmesg | grep firmware
\end{verbatim}
Kaip pavyzdį galima paimti Intel kortas, kurios reikalauja naudoti
kartu su tvarkyklėmis ir firmwarą:
\begin{verbatim}
firmware: requesting iwlwifi-5000-1.ucode
\end{verbatim}
Jeigu \textsl{dmesg} komanda nieko neparodė, vadinasi, Jūsų korta
nereikalauja jokio firmware.

\section{Laikrodžio nustatymas}

Konfigūruojat sistemą įdiegimo metu, Jūsų bus paprašyta pasirinkti
laikrodžio konfigūracijos tipą. Yra du laikrodžio konfigūracijos
tipai: UTC ir localtime.

\begin{itemize}
  \item Pasirinkite UTC, jeigu Jūsų kompiuteryje veikia tik
    \textsl{unix} tipo operacinės sistemos.
  \item Pasirinkite localtime, jeigu Jūsų kompiuteryje veikia ir kito
    tipo operacinės sistemos ( pavyzdžiui Windows 7 ).
\end{itemize}

\section{Kietojo disko paruošimas}

\paragraph{Svarbu}

Kietojo disko skaldymo procesas gali negrįžtamai pašalinti visus
duomenys, esančius diske. Tęsiant sekančius žingsnius, patariama
padaryti atsarginę visų Jums svarbių duomenų kopiją kitoje laikmenoje. 

\paragraph{Svarbu}

Sekančiuose žingsniuose pasirinkus ``Cancel'' kietojo disko paruošimas
nenutrūks. Norint nutraukti kietojo disko paruošimo procedūrą, reikia
visiškai išeiti iš įdiegimo. Tai galima padaryti \textsl{Ctrl+C}
komanda. Tik tokiu atveju visi procesai bus sustabdyti ir Jūsų
kietasis diskas liks nepakitęs.

\paragraph{Pastaba}

Visiškai nebūtina ruošti diską Arch Linux įdiegimui iš Arch Linux
įdiegimo atvaizdo. Tai galima atlikti ir iš kitos distribucijos ar net
Windows operacinės sistemos, pasitelkus disko paruošimo įrankius,
tokius kaip \textsl{Gparter} ir kt. Jeigu diskas buvo suskaldytas ir
paruoštas ankščiau, galite tęsti \textsl{Failų sistemos pajungimas}
temoje.\\

Patikrinkite, jog sistema atpažino Jūsų diską ir jo architektūra,
pasitelkiant \textsl{/sbin/fdisk} komanda su \textsl{-l} opcija.

Persijunkite į kitą konsolę ( Alt+F3 ) ir įveskite

\begin{verbatim}
fdisk -l
\end{verbatim}

Visai gerai būtų įsiminti kokius disko skirsnius Jūs norite skirti
Arch Linux sistemai. Dar geriau būtų - užsirašyti.

Persijunkite atgal į Arch Linux įdiegimą ( Alt+F1 )

Pasirinkite patį pirmą menu įrašą ``Prepare Hard Drive''.

\begin{itemize}
  \item 1 pasirinkimas: ``Auto Prepare''.\\
    ``Auto Prepare'' suskirsto Jūsų diską tokia architektūra:
    \begin{itemize}
      \item \textsl{/boot} skirstinys su \textsl{ext2} failų
        sistema. Numatytas dydis yra 32MB. Sistema gali suteikti Jums
        galimybę pakeisti /boot skirstinio dydį.
        Jeigu planuojate turėti daug branduolių, sveika pasirinkti
        šiek tiek daugiau ir dar plius kažkiek atsargai ( Tarkim 500MB
        ).
      \item \textsl{swap} skirstinys. Numatytas skirstinio dydis yra
        256MB. Sistema gali suteikti Jums galimybę pakeisti
        \textsf{swap} skirstinio dydį. Rekomenduojamas \textsl{swap}
        skirstinio dydis: \textsl{turimas Ram atminties kiekis} x 2
      \item Atskiri \textsl{/} ir \textsl{/home} skirstiniai, kurių
        dydžius taip pat galima keisti. Galima pasirinkti iš sekančių
        failų sistemos tipų: \textsl{ext2}, \textsl{ext3}, \textsl{ext4},
        \textsl{reiserfs}, \textsl{xfs} ir
        \textsl{jfs}. Rekomenduojama pasirinkti tokias pat failų
        sistemas tiek \textsl{/}, tiek \textsl{/home} skirstiniams.
    \end{itemize}
    Verta pastebėti, jog ``Auto Prepare'' visiškai pertvarkys turimą
    diską, t.y. ištrins visą informaciją ir visiškai perrašys disko
    architektūrą.

    \paragraph{Pastaba}

    ``Auto Prepare'' siūloma pasirinkti tiems, kurie pirmą kartą
    įdieginėja Arch Linux sistemą, pirmą kart mato
    \textsl{/sbin/fdisk} ir labai bijo . Vėliau, šiek tiek įgudus, sistemą
    vėlgi galima bus iš naujo įdiegti, tik šiuo atveju protingai
    suskirstyti diskų skirstinius.

  \item 2 pasirinkimas: ``Partition Hard Drives'' ( su \textsl{cfdisk}
    )

    Šitas pasirinkimas leis keisti diskų architektūrą ir skirstinių
    tipus taip, kaip nori vartotojas.

    Tie vartotojai, kurie jau yra pažįstami su \textsl{cfdisk} ir
    disko skirstinių sudarymų, gali praleisti sekančia temą ir tęsti
    \textsl{Paketų pasirinkimas} temoje, kuri yra toliau.

\end{itemize}

\subsection{Kietojo disko skaldymas}

\paragraph{Skirstinio informacija}

Kietojo disko skaldymas sudaro diske tam tikras atminties sritis,
kurios vadinamos skirstiniais, kurie elgiasi kaip savarankiški diskai.

Yra trijų tipų skirstiniai:
\begin{itemize}
  \item Primary
  \item Extended
  \item Logical
\end{itemize}

\textsl{Primary} skirsiniai gali būti kraunamieji skirsiniai (
bootable ), tačiau jų skaičius yra limituotas iki 4 viename kietame
diske. Jeigu sistemoje reikalaujama turėti daugiau kaip 4 skirstinius,
tuomet reikia naudoti kitą skirstinio tipą - \textsl{extended}, kuris
susidės iš \textsl{logical} skistinių.

Pats \textsl{extended} skirstinys yra beveiksmis ir bevertis, kadangi
pats \textsl{extended} skirstinys yra kaip talpa kitiems
\textsl{logical} skirsiniams.

\paragraph{Swap skirstinys}

Swap skirstinys yra rezervuota kietojo disko talpa, kurią sisteminis
branduolys galės naudoti kaip `RAM` atmintį, jeigu realios `RAM`
atminties neužteks duotai užduočiai įvykdyti.

Istoriškai, pagrindinis swap skirstinio reikalavimas yra x2 realios
RAM atminties dydis. Bėgant laikui, šita taisyklė tampa neaktuali,
kadangi pagrindinės atminties dydis asmeniniuose kompiuteriuose labai
padidėjo. Šiuo metu, jeigu Jūsų kompiuteryje yra \textsl{512MB}
pagrindinės atminties - dar galima taikyti x2 taisyklę, tačiau, jeigu
Jūsų kompiuteryje yra \textsl{1024MB} atminties - apie swap skirstinį
galite net pamiršti. Kodėl? Kadangi visuomet lieka galimybė susikurti
ne swap skirstinį, o swap failą, kuris atlikt tą patį vaidmenį, ką
atlieka ir swap skirstinys.

Šiame vadove mes naudosime \textsl{1GB} swap skirstinį.

\paragraph{Pastaba} Jeigu planuojate naudoti suspend-to-disk
(hibernate) swap skirstinys turi būti mažų mažiausiai lygus RAM
atminties dydžiui. Kai kurie Arch vartotojai rekomenduoja swap
skirstinį padaryti 10-20 proc didesnį, palikti atsargą klaidos
atvejui.

\paragraph{Skirstinių schema}

Skirstinių schema yra labai asmeninis reikalas. Nėra vieningo,
numatyto geriausiu sprendimo skirstinių schemai. Kiekvieno vartotojo
skirstinių schema bus skirtingai pritaikyta pagal jo poreikius ir
darbo sistemos reikalavimus.

Skirstinius galima ``pririšti'' prie tam tikrų direktorijų. Galimos
direktorijos ir jų apibūdinimas:

\begin{itemize}
  \item \textbf{/} ( root ) Root failų sistema yra pagrindinė failų
    sistema, iš kurios seka kitos failų sistemos. Jinai yra failų
    sistemos hierarchijos viršūnėje. Kiekviena direktorija seka po
    \textbf{/}, netgi tuomet, kai kažkuri direktorija yra pririšta
    prie kito disko.
  \item \textbf{/boot} Direktorija saugoja sisteminį branduolį,
    ramdisk atvaizdus ir krovėjo ( grub )
    konfigūraciją. \textsl{/boot} saugo visą informaciją, kuri
    reikalinga branduoliui, prieš paleidžiant sistemą. Tokia
    informacija gali būti išsaugoti \textsl{master boot sectors} arba
    \textsl{sector map} failai. \textsl{/boot} yra naudojamas tik
    sistemos krovimuisi, tačiau \textsl{/boot} gali būti iškeltas ir į
    kitą disko skirstinio vietą.
  \item \textbf{/home} Suteikia pakatalogį, kurio kiekvienas vardas
    sutampa su sistemoje priregistravusiais vartotojų
    vardais. \textsl{/home} saugoma visa informacija, susijusi su
    vartotojo veikla, vartotojo asmeniniais duomenimis ir vartotojo
    programų nustatymais.
  \item \textbf{/usr} Šita direktorija pagal svarba eina iškarto po
    \textsl{/} ( root ) direktorijos. Joje yra saugoma tokia
    informacija, kuri pasiekiama visiems sistemoms vartotojams,
    įskaitant ir programas bei tvarkykles, kurias gali naudoti iškarto
    keli vartotojai. \textsl{/usr} yra sistemiškai prieinama, tačiau
    ją galima tik skaityti. Tai leidžia suteikti prieigą tinkle
    esančiam vartotojui pasiekti \textsl{/usr} direktoriją, tačiau
    vartotojas negali tos informacijos perrašyti ar kitaip pakeisti.
  \item \textbf{/tmp} Direktorija atlieka ``laikinos failų saugyklos''
    vaidmenį. Kokia informacija gali būti laikina? Tai gali būti
    programų \textsl{užraktai} - '.lck' tipo failai, kurie yra
    naudojami sudarant sąlygas neleisti tai pačiai programai paleisti
    savo kopijas iš skirtinų vartotojų vienu metu. Visi duomenys iš
    \textsl{/tmp} yra pašalinami po kiekvieno sistemos užkrovimo.
  \item \textbf{/var} Direktorija saugo savyje visą informaciją apie
    kintamuosius: \textsl{spool} direktorijas ir failus,
    administravimo ir žurnalo ( log ) failus, \textsl{pacman} puodynę,
    ABS medį ir kt. Taip pat \textsl{/var} atlieka svarbų vaidmenį -
    suteikia galimybę užkrauti \textsl{/usr} skaitymo režime. Viskas,
    kas istoriškai buvo talpinama \textsl{/usr} direktorijoje,
    priklausė nuo \textsl{/var} direktorijos.
\end{itemize}

Kiekvienam vartotojui gali iškilti klausimas - o kam man skaldyti
diską į skirstinius ir paskui ``pririšinėti'' direktorijas prie
atskirų skirstinių? Juk realiai galima padaryti du skirtinius - vienas
swap, kitas / ( root ) direktorijai ir viskas.

Taip, ir toks variantas yra įmanomas, tačiau, disko skaldymas ir
skirstinių pririšimas prie direktorijų turi savo privalumų:

\begin{itemize}
  \item Saugumas: Kiekviena direktorija \textsl{/etc/fstab} faile gali
    būti sukonfigūruota būti 'nosuid', 'nodev', 'noexec', 'readonly'
    ir kt.
  \item Stabilumas: Vartotojas, arba kvaila programa gali visiškai
    užteršti diską bereikalingą informaciją, arba kritiškai reikalinga
    informacija ( ypač \textsl{/boot} skirstinyje ) gali būti pažeista
    ir sistema daugiau pati neužsikraus. 
  \item Greitis: Failų sistema, į kurią yra rašoma labai dažnai, gali
    patapti fragmentiška ( Geriausias būdas išvengti tokios problemos,
    yra nuolat stebėti ar failų sistema neužima viso disko talpos
    ). Atskiros failų sistemos yra atskirtos ir tarpusavyje negali
    sąveikauti.
  \item Vientisumas: Jeigu viena failų sistema sugadinama - kitos
    lieka nepažeistos.
  \item Universalumas: Duomenų dalinimasis tarp kompiuterių tampa daug
    saugesnis, kuomet naudojami atskiri diskai duomenims perduoti. 
\end{itemize}

Šiame vadove, mes atskirsim \textsl{/}, \textsl{/var}, \textsl{/home}
ir \textsl{swap} skirstinius.

\paragraph{Pastaba} \textsl{/var} direktorija susideda iš daug ir mažų
failų. Į tai reikia atsižvelgti, renkantis failų sistemos tipą.

\paragraph{Kokie turi būti mano skirstinių dydžiai?}

Toks klausimas yra atsakomas kiekvieno atskirai. Paprasčiausiais
atvejais galima apsiriboti tik root ir swap skirstiniais, arba dar
paprasčiau - vien tik root skirtiniu, be swap. Taip pat galite
paeksperimentuoti ir pasirinkti tokią pat skirstinių ir direktorijų
architektūrą, kaip ir mūsų pavyzdyje:

\begin{itemize}
  \item Root failų sistema ( \textbf{/} ) turės savyje \textsl{/usr}
    direktorija, kuri yra gan didelė. Į tai turi būti
    atsižvelgta. Apie 15-20GB šiai direktorijai turėtų būti užtektinai
    kiekvienam vartotojui.
  \item \textbf{/var} failų sistema susidės iš daugybės duomenų, tarp
    kurių ir ABS medis, bei pacman puodynė. Paketų saugojimas
    kompiuteryje turi savo privalumų - bet kada galima įdiegti senesnę
    programos versiją. \textsl{/var} turi tendencija didėti - pacman
    puodynė didėja nuolatos ir jinai gali labai didelę po ilgo pacman
    naudojimo. Jeigu naudojate SSD tipo diską, patartiną perkelti
    \textsl{/var} direktoriją į HDD tipo diską, taip išsaugant SSD
    tipo diską nuo bereikalingų rašymo/skaitymo operacijų. Darbiniam
    kompiuteryje \textsl{/var} direktorijai galima skirti 8-12GB disko
    vietos. Serveriai pasižymi ypač dideliais \textsl{/var}
    direktorijos matmenimis.
  \item \textsl{/home} direktorija yra ta vieta, kur saugomi vartotojo
    asmeniniai duomenys, atsiųstas turinys ir kt. Darbiniame
    kompiuteryje, \textsl{/home} direktorija dažniausiai yra pati
    didžiausia. Verta prisiminti, jog jeigu Jūs iš naujo diegsite Arch
    Linux - Jums \textsl{/home} direktorija niekur nedings ( jeigu
    ``pririšote'' \textsl{/home} direktoriją prie kito skirstinio ).
  \item Kiekvieno disko dydžio 25 procentai nueina apsaugojimui nuo
    neprognozuotų atsitikimų, sistemos išplėtimo ir vaidins gerą
    priemonę prieš fragmentaciją.
\end{itemize}

\paragraph{Skirstinių kūrimas su cfdisk}

Pradėkite sukurdami naują skirstinį, kuris bus pririštas prie root
failų sistemos.

Pasirinkite \textbf{N}ew -> Primary ir įveskite norimą root failų
sistemos skirstinio dydį. Padėkite diską schemos pradžioje.

Taip pat pasirinkite \textbf{T}ype '83 Linux'. Naujai sukurtas
skirstinys, kuris bus pririštas prie \textsl{/} ( root ) failų
direktorijos, turėtų pasirodyti \textsl{sda1} pavadinimu.

Dabar sukurkite dar vieną \textsl{primary} '83 Linux' tipo
skirstinį. Šitas skirstinys bus pririštas prie \textsl{/var} failų
direktorijos. Jis turėtų pasirodyti \textsl{sda2} pavadinimu.

Sekantis žingsnis būtų sukurti \textsl{swap} skirstinį. Pasirinkite
norimą dydį ir '82 ( Linux swap / Solaris )' tipą. Sukurtas skirstinys
turėtų pasirodyti kaip \textsl{sda3}.

Paskutinis žingsnis - sukurti skirstinį, kuriame gulės \textsl{/home}
direktorija. Pasirinkite \textsl{primary} ir '83 Linux' skirstinio
tipą. Sukurtas skirstinys pasirodys kaip \textsl{sda4}.

Pavyzdžiui:

\begin{verbatim}
Name    Flags     Part Type    FS Type           [Label]         Size (MB)
-------------------------------------------------------------------------
sda1               Primary     Linux                             15440 #root
sda2               Primary     Linux                             10256 #/var
sda3               Primary     Linux swap / Solaris              1024  #swap
sda4               Primary     Linux                             140480 #/home
\end{verbatim}

Telieka tik išsaugoti skirstinių architektūra pasirinkus
\textbf{W}rite ir surinkti '\textsl{yes}'. Po šitos operacijos
\textsl{cfdisk} visiškai ištrins informaciją iš kietojo
disko. Pasirinkite \textbf{Q}uit, norint išeiti į
programos. Pasirinkite \textsl{Done}, norint išeiti iš menu ir tęsti
su \textsl{Direktorijų pririšimas}

\subsection{Direktorijų pririšimas}

Parinkite kiekvienam skirstiniui pririšama failų sistemos
direktoriją ( Nepamirškite, jog skirstiniai baigiasi numeriais. Taip
pat \textsl{sda} reiškia net ne skirstinį, o visą diską aplamai ).

\paragraph{Failų sistemos tipai}

Failų sistemos pasirinkimas yra labai asmeninis reikalas. Kiekvienas
renkasi savo failų sistemą pagal jo poreikius. Kiekvienas failų
sistemos tipas turi savo pliusų, minusų ir unikalumų. Trumpai galime
aprašyti Arch Linux palaikomas failų sistemas:

\begin{enumerate}

  \item \textbf{ext2} \textsl{Second Extended FileSystem} - sena,
    patikima GNU/Linux failų sistema. Labai stabili, bet be žurnalo
    palaikymo. Tikrai netinka \textsl{/} ( root ) ir \textsl{/home}
    direktorijoms, dėl labai ilgo fsck'o. Failų sistema \textsl{ext2}
    gali būti lengvai konvertuota į \textsl{ext3} failų
    sistemą. Dažniausiai \textsl{ext2} pasirenkama \textsl{/boot}
    direktorijai.
  \item \textbf{ext3} \textsl{Third Extended FileSystem} - savo
    originale yra \textsl{ext2} failų sistema su žurnalo
    palaikymu. Failų sistema \textsl{ext3} turi atgalinį palaikymą
    \textsl{ext2} failų sistemai. Ypač stabili, brandi ir kol kas
    plačiausiai naudojama failų sistema. Failų sistema buvo kuriama
    Gnu/Linux.
  \item \textbf{ext4} \textsl{Fourth Extended FileSystem} - turi
    atgalinį \textsl{ext3} ir \textsl{ext2} palaikymą. Pristato diskų
    palaikymą, kurių talpa siekia virš 1 exabaito ir failo dydžių,
    kurių svoris siekia 16 terabaitų. Padidėjo ir subdirektorių
    palaikymas - nuo 32 000 ( ext3 ) iki 64 000. Pat pat siūlo realaus
    laiko fragmentavimą.
  \item \textbf{ReiserFS} (V3) - tai aukštos kokybės žurnalinė failų
    sistema, kuri naudoja labai neįprasta ir kūrybinga duomenų
    perdavimo algoritmą. ReiserFS dirba labai greitai, ypač jeigu
    kalba eina apie daug mažų bylų. ReiserFS yra greitai formatuojama,
    tačiau labai lėta pririšime. Pakankamai brandi ir
    stabili. ReiserFS šiuo metu nėra vystoma ( Reiser4 yra naujausia
    Reiser failų sistema ). Rekomenduojamą ReiserFS pasirinkti
    \textsl{/var} direktorijai.
  \item \textbf{JFS} - IBM sukurta \textbf{J}ournaled
    \textbf{F}ile\textbf{S}ystem yra pati pirma failų sistema, kuri
    turėjo žurnalo palaikymą. Iki prisijungimo prie Gnu/Linux IBM
    ilgus metus naudojo JFS savo AIX Operacinėje sistemoje. Šiuo metu
    JFS reikalauja mažiausiai sistemos resursų iš visų Gnu/Linux failų
    sistemų. Labai greita formatavime, pririšime ir gera visuose
    aspektuose, ypač jeigu ateina kirtis iš įvesties/išvesties
    įrenginio. Ne taip plačiai palaikoma kaip ext ar ReiserFS, tačiau
    labai brandi ir stabili sistema.
  \item \textbf{XFS} - dar viena ankstyva žurnalo palaikymą turinti
    failų sistema. Ją sukūrė Silicon Graphics IRIX operacinei
    sistemai, o vėliau ji buvo prijungta prie Gnu/Linux. XFS siūlo
    labai greitą duomenų apsikeitimą dirbant su dideliais skirstiniais
    arba didelėmis bylomis.

\end{enumerate}

\paragraph{Pastaba} JFS ir XFS sistemos negali būti sumažintos disko
skaldymo programų ( kaip gparter ar parted magic ).

\paragraph{Pastaba apie žurnalo palaikymą}

Visos ( išskyrus ext2 ) viršuje išvardintos failų sistemos turi
žurnalo palaikymą. Tokios failų sistemos yra gan
lanksčios klaidų atveju. Tai pasiekiama labai paprastai - kai
vartotojas padaro korekciją byloje - žurnalinė sistema pirmiausiai
įrašo pakeitimo informaciją į savo žurnalą, o tik paskui pakeičia
realią informaciją. Verta pastebėti, jog ne visos žurnalinės sistemos
yra vienodos; pavyzdžiui tik ext3 ir ext4 sistemos siūlo data-mode
žurnalo palaikymą. Tai reiškia, jog žurnalinė sistema savo žurnale
saugo tiek duomenis, tiek meta duomenis ( tačiau tokiu atveju labai
nukenčia sistemos greitis ). Kiti siūlo ordered-mode. Tokiu atveju
žurnale saugomi tik meta duomenis. Tačiau bet kokiu atveju, visos
žurnalinės sistemos atstatys jūsų failų sistemą po lūžio. data-mode
siūlo geriausią duomenų apsauga, tačiau tai gali įtakoti sistemos
greitį, kadangi duomenys yra rašomi du kartus - vieną kartą į žurnalą,
o kitą kartą į diską. Remiantis kokio svarbumo duomenys bus saugomi
diske, atitinkamai reikia pasirinkti ir disko failų sistemą.

\paragraph{Tęsiam...}

Pasirinkite ir sukurkite failų sistemą ( skirstinio formatavimas ) ir
pririškite skirtinį prie \textbf{/} direktorijos, pasirinkdami
\textbf{yes}. Toliau sistema paragins pridėti papildomus
skirtinius. Mūsų pavyzdyje lieka sda2 ir sda4. Sda2 skirtiniui
parenkame failų sistemą ir pririšam prie \textbf{/var}. Ir galiausiai
parenkam sda4 skirstiniui failų sistemą ir pririšam jį prie
\textsl{/home}.

\paragraph{Pastaba} jeigu nesukūrėte arba Jums tiesiog nereikia
atskirto \textbf{/boot} skirstinio - ignoruokite pranešimą, kurį
gausite apie \textbf{/boot} direktoriją.

Grįžkite į pagrindinį menu.

\section{Paketų pasirinkimas}

\begin{itemize}
  \item Core ISO: Savo paketų šaltiniu pasirinkite CD diską.
  \item Netinstall: Pasirinkite FTP/HTTP veidrodį. \textsl{Verta
    pažymėti, jog archlinux.org greitis yra sumažintas iki 50KB/s.}
  \item Visi įdiegiami paketai yra tik iš [core] saugyklos. Jie yra
    padalinti į dvi grupes:
    \begin{itemize}
      \item \textbf{Base}: Paketai iš [core] saugyklos, kurie suteikia
        minimalią aplinką. Visuomet yra būtina pasirinkti šitą
        kategoriją, tačiau galima pasirinkti, kokius paketus
        pašalinti.
      \item \textbf{Base-devel}: Papildomi įrankiai iš [core]
        saugyklos: \textbf{make}, \textbf{automake} ir kt. Daugumai
        naujokų derėtų pasirinkti šitą kategoriją, nes šitų įrankių
        ankščiau ar vėliau vistiek prireiks.
    \end{itemize} 
\end{itemize}

Po kategorijos pasirinkimo, jums bus pateiktas pilnas paketų
sąrašas. Naudodamiesi tarpo klavišu galite pažymėti arba atžymėti
paketą.

\paragraph{Pastaba} Po kategorijos pasirinkimo, visi ten esantys
paketai bus pažymėti įdiegimui.

\paragraph{Pastaba} Jeigu yra reikalaujamas bevielis ryšis,
prisiminkite pasirinkti įdiegimui \textbf{wireless$\_$tools}
paketą. Kai kurie bevielio tinklo sąsajos taip pat reikalauja
\textbf{ndiswrapper} ar/ir specifinės \textbf{firmware}. Jeigu bus
naudojamas WPA kodavimas, taip pat reikalinga pasirinkti
\textbf{wpa$\_$supplicant} paketą. Taip pat labai pravartu pasirinkti
ir \textbf{netcfg}, kuris padės konfigūruojant tinklą ir profilius.


Po paketų pasirinkimo, palikite pasirinkimo langą ir tęskite toliau
\textsl{Paketų įdiegimas}

\section{Paketų įdiegimas}

Toliau pasirinkite ``Install Packages''.

\begin{itemize}
  \item Netinstall: Dabar pacman paketų tvarkyklė atsiųs ir įdiegs
    paketus iš saugyklos. Eigą galima peržiūrėti Alt+F5, grįžti atgal į
    diegimo langą galima su Alt+F1.
  \item Core atvaizdas: pacman paketus ims iš CD/USB atvaizdo. 
\end{itemize}

Kai kurios įdiegimo programos paklaus ar nenorite išsaugoti paketus į
pacman programos podėlį. Jeigu pasirinksite 'yes', tuomet turite
galimybę įdiegti programų senesnes versijas po jų atnaujinimų, todėl
rekomenduojama yra pasirinkti 'yes'. Ateityje bet kada bus galima
ištrinti viską iš pacman programos podėlio. Įdiegimo programa dabar
turėtų įdiegti visus paketus, kaip ir Arch 2.6 branduolį į naują
sistemą.

Po paketų parsiuntimo, įdiegimo programa patikrins jų
vientisumą. Toliau, jinai sukurs branduolį iš parsiųstų paketų.

\section{Sistemos konfigūravimas}

\textsl{Atidus sekimas ir supratimas yra kritiniai kriterijai, norint
  teisingai susikonfigūruoti sistemą.}

\begin{itemize}
  \item Šiame žingsnyje yra galimas pagrindinės Arch Linux sistemos
    konfigūravimas.
  \item Ankstesnės įdiegimo versijos naudojosi \textsl{hwdetect}
    surinkti informaciją apie esamą sistemą. Tokia technika jau
    pasenusi. Šiuo metu \textsl{udev} turėtų automatiškai atpažinti ir
    įkelti į branduolį reikalingus modulius sistemos krovimo metu.
\end{itemize}

Dabar bus suteikta galimybė pasirinkti redaktorių: \textsl{nano},
\textsl{joe} arba \textsl{vi} ( \textsl{nano} yra pats lengviausias
naudojime iš visų trijų). Po pasirinkimo, bus parodytas sąrašas bylų,
kurias galima konfigūruoti.

\paragraph{Pastaba} Šiame žingsnyje labai svarbu visus konfigūracinius
failus pakoreguoti arba bent atidaryti ir įsitikinti, kad viskas
gerai. Dažniausiai pasitaikanti klaida yra, kai vartotojai tiesiog
praleidžia šitą žingsnį.

\paragraph{Ar įdiegimo programa gali tai atlikti automatizuotai?}

Slėpti sistemos konfigūravimą yra visiška ``The Arch Way''
priešingybė. Šiuo metu, naujausios Linux branduolio versijos ir
aparatinės įrangos įrankiai siūlo tikrai gerą įrangos palaikymą ir
automatinį konfigūravimą, tačiau Arch pateikia vartotojui visas galimas
sistemos konfigūracijos galimybes, kadangi taip išlaikomas aiškumas ir
sistemos resursų kontrolė. Kuomet baigsite redaguoti arba bent
peržiūrinėti konfigūracines bylas, jau turėsite bazinį supratimą apie
Arch Linux sistemos rankinį konfigūravimą ir bazinę struktūrą. Tokia
patirtis pravers naudojant ir sėkmingai palaikant sistemą po įdiegimo
pabaigos.

\subsection{/etc/rc.conf}

Arch Linux naudoja \textsl{/etc/rc.conf} kaip pagrindinę sisteminę
konfigūracinę bylą. Byla sudaro didelė įvairovė konfigūraciniu
nustatymu, kurie pagrinde reikalingi sistemos krovimosi metu. Kaip
nusako ir pats bylos pavadinimas - konfigūracinė byla nusako visų
\textsl{/etc/rc*} bylų paleidimą, bei jų konfigūravimą. 

\subsubsection{LOCALIZATION sekcija}

\begin{itemize}
  \item \textbf{LOCALE=}: Šita eilutė nusako sistemos lokalę, kuri bus
    naudojama visų i18n programų ir įrankių. Galimų lokalių sąrašą
    galima peržiūrėti su \textsl{locale -a} komanda iš komandinės
    eilutės. Rekomenduojama palikti ``en$\_$US. Vėliau galima bus
    susigeneruoti dvi lokales - tiek lietuvišką, tiek anglišką.
  \item \textbf{HARDWARECLOCK=}: Nusako kokiu formatu bus saugomas
    laikas įrenginyje, kuomet yra atliekama sinchronizacija pakrovimo
    ir stabdymo metu: \textsl{UTC} arba \textsl{localtime}. UTC yra
    labai geras, kadangi jis labai supaprastina visą laiko saugojimo
    procesą, tačiau, jeigu planuojate savo kompiuteryje turėti ir
    kitas operacinės sistemas, tokias kaip Windows, patartina yra
    pasirinkti localtime.
  \item \textbf{USEDIRECTISA=}: Nustatymu galima pasakyti, jog sistema
    naudos tiesioginį Į/I kreipinį į įrangos laikrodį, o ne
    \textsl{/dev/rtc}.
  \item \textbf{TIMEZONE=}: Nusako laiko juostą. Visas galimas laiko
    zonas galite peržiūrėti \textsl{/usr/share/zoneinfo}.
  \item \textbf{KEYMAP=}: Nusako klaviatūros išdėstymą. Visus galimus
    klaviatūros išdėstymus galima rasti
    \textsl{/usr/share/kdb/keymaps}. Šitas nustatymas veikia tik TTY
    aplinkoje, jis visiškai neįtakoja jokias langų tvarkykles ar
    \textbf{X}.
  \item \textbf{CONSOLEFONT=}: Komandinės eilutės šriftas. Visus
    galimus komandinės eilutės šriftus galite peržiūrėti
    \textsl{/usr/share/kdb/consolefonts}. Pagal numatytus nustatymus,
    tinka ir tuščias įrašas.
  \item \textbf{CONSOLEMAP=}: Nusako komandinės eilutės žemėlapį su
    \textsl{setfont} programa paleidimo metu. Galimus komandinės
    eilutės žemėlapius galima rasti
    \textsl{/usr/share/kbd/consoletrans}, žinoma, jeigu tai yra
    būtina. Pagal numatytus nustatymus tuščias įrašas tinka.
  \item {USECOLOR=}: Pasirinkite ``yes'', jeigu turite monitorių su
    spalvomis. :)
\end{itemize}
Byloje ``LOCALIZATION'' sekcija turi atrodyti panaši į:
\begin{verbatim}
LOCALE="en_US.utf8"
HARDWARECLOCK="localtime"
USEDIRECTISA="no"
TIMEZONE="Europe/Vilnius"
KEYMAP="us"
CONSOLEFONT=
CONSOLEMAP=
USECOLOR="yes"
\end{verbatim}

\subsubsection{HARDWARE sekcija}

\begin{itemize}
  \item \textbf{MOD$\_$AUTOLOAD=}: Jeigu nustatysite į ``Yes'', tuomet
    naudosite \textbf{udev} automatiniam kompiuterio geležies
    aptikimui ir reikiamo modulio pakrovimui į sistemos
    branduolį. Jeigu nustatysite ``No'' viskas priklausys tik nuo Jūsų
    pačių savo kompiuterio žinių. Gali kilti būtinybė net kompiliuoti
    savo branduolį, modulius ir kt.
  \item \textbf{MOD$\_$BLACKLIST=}: Sekanti eilutė buvo pašalinta iš
    palaikymo sąrašo. Kaip alternatyva šiuo metu yra naudojama
    \textbf{MODULES=} eilutė, kuri nurodoma žemiau.
  \item \textbf{MODULES=}: Vartotojo nustatomi papildomi
    moduliai. Jeigu sistema turi floppy įrenginį, reikia pridėti
    ``floppy''. Jeigu naudosite ``loopback'' failų sistemas, tai
    galite pridėti ``loop''. Jeigu nenorite, jog tam tikras modulis
    pasikrautų automatiškai ( tai gali kilti, jeigu Jums reikės
    naudoti kitas tvarkykles, negu Jums užkrauna \textbf{udev} ), prie
    modulio pavadinimo pridėkite šauktuką (!). Tokiu atveju,
    \textbf{udev} bus priverstas nekrauti nurodyto modulio į
    branduolį. 

    Kaip pavyzdį galime pateikti užblokuotą \textsl{pcspeaker}:

    \begin{verbatim}
MODULES=(!snd_pcsp !pcspkr loop)
    \end{verbatim}
\end{itemize}

\subsubsection{NETWORKING sekcija}

\begin{itemize}
  \item \textbf{HOSTNAME=}: Hostname galite pasirinkti tokį, koks Jums
    patinka. Tai yra Jūsų kompiuterio vardas tinkle. Kokį vardą
    bepasirinktumėt, svarbiausią, jį įtraukti ir į
    \textsl{/etc/hosts}.
  \item \textbf{eth0=}: Sekantis punktas verčiasi kaip 'Ethernet, card
    0'. Jeigu Jūs turite \textbf{statinį IP}, pridėkite prie sekančios
    eilutės savo IP adresą, netmask ir broadcast adresą. Jeigu Jūs
    naudojate \textbf{DHCP}, prie sekančios eilutės parašykite tik
    dhcp ( eth0=''dhcp'' ) ir Jums tinklas bus sukonfigūruotas
    automatiškai.
  \item \textbf{INTERFACES=}: Čia galite nurodyti savo
    sąsajas. Keletas sąsajų turi būti atskirtos tarpu, kaip
    pavyzdžiui:
    \begin{verbatim}
(eth0 eth1 wlan0)
    \end{verbatim}
  \item \textbf{gateway=}: Jeigu naudojate \textbf{statinį IP},
    nurodykite savo getaway adresą. Jeigu naudojate \textbf{DHCP}
    galite praleisti sekančią eilutę. Tačiau kai kurie vartotojai
    nurodė, jog ir naudojant DHCP, reikia nurodyti savo
    getaway. Pirma, pabandykite nieko nenurodyti, o jeigu prie tinklo
    kompiuteris vistiek nesijungia - nurodykite savo getaway.
  \item \textbf{ROUTES=}: Jeigu naudojate \textbf{statinį IP},
    pašalinkite \textbf{!} prieš 'getaway'. Jeigu naudojate
    \textbf{DHCP}, galite palikti sekantį kintamąjį
    užkomentuotą. Tačiau, vėl gi, jeigu Jūsų kompiuteris neprisijungs
    prie interneto, naudokite statinio IP nustatymus. 
\end{itemize}

Pavyzdys naudojant dinaminį IP ( \textbf{DHCP} ):

\begin{verbatim}
HOSTNAME="laptop"
eth0="dhcp"
INTERFACES=(eth0)
gateway="default gw 192.168.0.1"
ROUTES=(!gateway)
\end{verbatim}

Pavyzdys naudojant \textbf{statinį} IP:

\begin{verbatim}
HOSTNAME="laptop"
eth0="eth0 192.168.0.2 netmask 255.255.255.0 broadcast 192.168.0.255"
INTERFACES=(eth0)
gateway="default gw 192.168.0.1"
ROUTES=(gateway)
\end{verbatim}

Pakoreguokite \textsl{/etc/resolv.conf} nurodydami DNS
serverius. Pavyzdžiui:

\begin{verbatim}
search my.isp.net
nameserver 192.168.1.1
nameserver 192.168.1.2
nameserver 192.168.1.3
\end{verbatim}

Kai kurie procesai gali perrašyti \textsl{/etc/resolv.conf}
turinį. Pavyzdžiui, pagal numatytus nustatymus Arch Linux naudoja
\textbf{dhcpcd} DHCP klientą, kuris gali perrašyti bylos turinį, kai
yra paleidžiamas. Kai kurie metodai gali išsaugoti nuo perrašymo
sekančią bylą. Pavyzdžiui, galima nurodyti \textbf{dhcpcd}
konfigūracinėje byloje, kad programa neperrašinėtų
\textsl{/etc/resolv.conf} bylos turinį. Tam, tiesiog reikia pridėti
\textsl{/etc/dhcpcd.conf} bylos turinio pabaigoje:

\begin{verbatim}
nohook resolv.conf
\end{verbatim} 

\subsubsection{DEAMONS sekcija}

Sekantis masyvas yra paprastas skriptų sąrašas, kurie yra
\textsl{/etc/rc.d} direktorijoje. Šioje eilutėje galima nurodyti kokie
būtent skriptai bus paleisti sistemos krovimo metu ( taip pat ir jų
eilė ). Asinchroninis paleidimas taip pat palaikomas ( tereikia prie
skripto pridėti '@' ) ir jis labai paspartina sistemos krovimą.

\begin{verbatim}
DAEMONS=(network @syslog-ng netfs @crond)
\end{verbatim}

\begin{itemize}
  \item Jeigu prie skripto pavadinimo pridėti šauktuką (!), tai
    skriptas nebus paleistas.
  \item Jeigu prie skripto pavadinimo pridėti sraigę (@), tai skriptas
    bus paleistas asinchroniniu būdu. Paleidimo eilė nelauks, kol
    skriptas sėkmingai arba nesėkmingai bus užbaigtas, o tęs krovimą toliau.
  \item Jeigu į sistemą buvo įdiegtas naujas servisas ( tarkim 'httpd'
    ), galite pridėti jį prie DAEMONS sekcijos ir kiekvieną kartą
    sistema paleis 'httpd' ( apache2 ) jos krovimo metu. 
\end{itemize}

\subsubsection{Apie DEAMONS}

Deamons eilutė turi būti pakoreguota pagal kiekvieno vartotojo
poreikius, tačiau, dabar būtina truputi pakalbėti apie deamons'us. 

Deamon yra programa, kuri yra vykdoma šešėlyje ir kuri laukia
pertraukties. Kai įvyksta pertrauktis - deamon siūlo savo sprendimus
pertraukčiai apdoroti. Geras pavyzdys yra web serveris, kuris laukia,
kol į jį bus padaryta kreiptis ( 'httpd' ) arba ssh serveris, kuris
laukia, kol į jį bus padaryta kreiptis ( 'sshd' ). Tokios programos
yra pilnos, tačiau yra programų, kurių darbą ne taip lengva
pastebėti. Kaip pavyzdį galima nurodyti programą, kuri rašo visus
pranešimus į sisteminį žurnalą ( 'syslog', 'metalog' ) ir programos,
kurios suteikia grafinį priėjimą prie sistemos ( 'gdm', 'kdm' ). Visos
sekančios programos gali būti įtrauktos į deamon sąrašą ir paleistos
sistemos krovimo metu. Vėliau pateiksime tam tikras, naudingas deamon
programas. 

Istoriškai, terminas \textsl{deamon} prigijo dėka MIT projekto MAC
programuotojų. Jie pasiskolino pavadinimą iš \textsl{Maxwell demon},
įsivaizduojamą sutvėrimą iš įžymaus ir sudėtingo eksperimento, kuris
visuomet dirbą šešėlyje, rikiuodamas molekules. *nix sistemos
pasisavino šitą terminą ir pakeitė jo kilmę kaip į žodžių junginį
``\textbf{d}isk \textbf{a}nd \textbf{e}xecution \textbf{mon}itor''.


\subsection{/etc/fstab}

\textbf{Fstab} ( trumpinimas iš žodžių \textbf{f}ile \textbf{s}ystems
\textbf{tab}le ) yra dalis sistemos konfigūracijos, kuriame nurodomi
visi galimi diskų ir disko skirstinių elgsena sistemoje, t.y. prie
kurios direktorijos ir kokiomis teisėmis turi būti pririšti diskai,
bei jų skirstiniai. Byla \textsl{/etc/fstab} dažniausiai naudojama
\textbf{mount} programos. Mount komanda paima disko skirstinio failo
sistemą ir prijungia ją prie sisteminės direktorijų
hierarchijos. Paleidimo metu, kuomet praeina 3/4 viso paleidimo,
\textbf{mount -a} komanda perskaito \textsl{/etc/fstab} bylą ir pagal
perskaitytus nustatymus prijungia nurodytus skirstinius prie
direktorijų hierarchijos. Jeigu prie skirstinio yra parašyta
\textsl{noauto}, sistemos krovimo metu \textbf{mount -a} skirstinio
niekur nejungs.

\subsubsection{/etc/fstab pavyzdys}

\begin{verbatim}
# <file system> <dir>     <type>   <options>               <dump>    <pass>
none            /dev/pts  devpts   defaults                  0         0
none            /dev/shm  tmpfs    defaults                  0         0
/dev/sda1       /         jfs      defaults,noatime          0         1
/dev/sda2       /var      reiserfs defaults,noatime,notail   0         2
/dev/sda3       swap      swap     defaults                  0         0
/dev/sda4       /home     jfs      defaults,noatime          0         2
\end{verbatim}

\begin{itemize}
  \item \textbf{<file system>}: nusako disko skirstinį arba nutolusi
    failų sistemą su kuria bus dirbama. 
  \item \textbf{<dir>}: nusako direktoriją, prie kurios bus pririštas
    ankščiau nurodytas disko skirstinys arba nutolusi failų
    sistemą. Jeigu skirstinys yra \textsl{swap} tipo, čia turi būti
    nurodytas 'swap'. Verta pastebėti, jog swap skirstiniai realiai
    nėra prijungiamos prie direktorijų hierarchijos.
  \item \textbf{<type>}: nusako failų sistemos tipą. Linux branduolys
    palaiko labai daug failų sistemų. Galite patikrinti kokias failų
    sistemas palaiko sisteminis branduolys, peržiūrėję
    \textsl{/proc/filesystems} direktoriją. Įrašas 'swap', nurodo, jog
    bus dirbama su swap tipo skirstiniu ar byla. Įrašas 'ignore'
    nurodo, jog sekanti eilutė turi būti ignoruojama. Toks įrašas
    naudingas tuomet, kai tenka laikinai atjungi kokį nors išorinį ar
    vidinį diską.
  \item \textbf{<options>}: nusako parinktis, kurios bus įvykdytos
    prijungimo metu. Eilutė formatuojama kaip parinkčių sąrašas, kur
    kiekviena parinkti atskiriama kablelių, be jokių tarpų. Pagrinde,
    eilutė turi susidėti iš prijungimo tipo ir dar papildomos
    parinktys, kurios priklauso nuo failų sistemos tipo. Detalesnei
    dokumentacijai peržiūrėkite 'man mount'.
  \item \textbf{<dump>}: nusako kokia failų sistema turi būti perkelta
    į 'sąvartyną'. Dump yra savotiška atsarginių kopijų darymo
    tarnyba. Jeigu penktas laukas nėra nurodomas, skirstinys nurodomas
    kaip nereikalaujantis atsarginių kopijų darymo. 
  \item \textbf{<pass>}: nusako failų sistemos tikrinimo prioritetą
    sistemos krovimosi metu. Pagrindinė failų sistema turi būti
    nurodoma 1, o visos kitos turi turėti nurodymą 0 arba 2. Failų
    sistemos, kurios yra tam pačiam diske, bus tikrinamos
    sinchroniškai. Failų sistemos, kurios yra skirtinguose
    diskuose, bus tikrinamos tuo pačiu metu naudojant paralelizmą,
    esantį techninėje įrangoje. Jeigu šeštas parametras nėra nurodomas
    arba yra 0, fsck netikrins failų sistemos. 
\end{itemize}

\subsection{/etc/mkinitcpio.conf}

  \textsl{Daugumai vartotojų nereikia redaguoti sekančios konfigūracinės
    bylos, tačiau galite perskaityti nurodytą informaciją savo žinių
    gilinimui.}

  Konfigūracinė byla leidžia toliau tęsti kruopštų sistemos nustatymą
  ties ram failų sistema arba initramfs arba istoriškai vadinamą
  initrd. Initramfs yra gzip suarchyvuotas sistemos atvaizdas, kuris
  gali būti tik skaitomas sistemos krovimo metu. Initramfs tikslas yra
  suteikti tiltą sistemai iki pagrindinės failų sistemos. Tai reiškia,
  kad jis turi užkrauti visus reikiamus modulius į sisteminį
  branduolį. Tuo metu, kai initramfs užkrauna reikiamus modulius
  automatiškai, arba rankiniu būdu, viskas toliau perduodama
  sisteminiam branduoliui. Sekant iš initramfs paskirties, byloje turi
  būti nurodomi tik moduliai, kurie yra reikalingi norint sėkmingai
  pasiekti sistemos branduolį ir pagrindinę failų sistemą. Jam
  nereikia nurodyti kiekvieno modulio, kuris bus naudojamas
  sistemos. Likusi dalis moduliu bus užkrauta vėliau, kartu su
  branduoliu, udev pagalba, init metu. 

  \textbf{mkinitcpio} yra sekanti karta \textbf{initramfs} kūrime. Jis
  turi labai daug privalumu, lyginant su senais \textbf{mkinitrd} ir
  \textbf{mkinitramfs} skriptais.

  \begin{itemize}
    \item Jis naudoja \textbf{glibc} ir \textbf{busybox}. Taip
      suteikiama maža ir lengva bazė.
    \item Jis naudoja \textbf{udev} krovimo metu taip pašalindamas
      modulius, kurie nėra reikalingi norint pasiekti sisteminį
      branduolį, bei pagrindinę failų sistemą. 
    \item Jo kablio tipo paleidimo skriptai ( hooks ) yra lengvai praturtinami
      su papildomais kabliais, kurie įtraukiami per pacman
      programą. Taip visiškai nereikia redaguoti mkinitcpio bylos.
    \item Jis palaiko \textbf{lvm2}, \textbf{dm-crypt}, \textbf{raid},
      \textbf{swsusp} bei \textbf{suspend2} pažadinant ar užmigdant ir
      krovimą iš usb įrangos.
    \item Daugelis ypatybių gali būti pakeisti per sistemos branduolio
      komandinę eilutę, nereikalaujant papildomai kompiliuoti
      atvaizdo.
    \item Mkinitcpio skriptas laidžia įtraukti sisteminį branduolį į
      atvaizdą bei tiesiog būti sisteminiam branduolyje. 
    \item Jo lankstumas daugeliu atveju nereikalauja perkompiliuoti
      sisteminio branduolio.
  \end{itemize}

  Naudojant RAID arba LVM pagrindinėje failų sistemoje, turi būti
  sukonfigūruoti tam tikri kabliai ( HOOKS ). Pridėkite ``usbinput''
  jeigu naudojate usb klaviatūrą. Nepamirškite pridėti ``usb'', jeigu
  diegiate Arch Linux į usb laikmeną, kaip pavyzdžiui:

  \begin{verbatim}
HOOKS="base udev autodetect pata scsi sata usb filesystems keymap usbinput"
  \end{verbatim}

  Jeigu yra būtinas USB įrenginių, FireWire, PCMCIA, NFS, RAID, LVM2,
  užkoduotų laikmenų ar DSDT palaikymas - atitinkamai sukonfigūruokite
  kablius ( HOOKS ).

  \textbf{Mkinitcpio} yra Arch inovacija, kuri buvo kuriama Aaron
  Griffin ir Tobias Powalowski su tam tikra pagalba iš bendruomenės. 

\subsection{/etc/modprobe.d/modprobe.conf}

  Sekanti konfigūracinė byla gali būti naudojama papildomiems
  nustatymams branduolio moduliams. Nėra reikalavimo redaguoti
  sekančią bylą.

\subsection{/etc/resolv.conf ( statiniam IP )}

  

\subsection{/etc/hosts}
